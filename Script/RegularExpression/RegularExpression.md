## Regular Expression / 正则表达式

---

#### 正则表达式精要

###### 元字符

    ( [ { \ ^ $ | ) ? * + .
    如果要在正则中匹配这些元字符，需要加转义符 \

###### 特殊字符

    \t：制表符
    \v：垂直制表符
    \n：换行符 
    \r：回车符
    \f：换页符
    \a：alert 字符
    \e：escape 字符
    \0：空字符

###### 字符类

    简单类：
        [] 这个整体对应一个字符；
    负向类
        [] 中首字符设为^，匹配不能为括号里面的字符；
    范围类
        匹配的东西过多且类型又相同，全部输入太麻烦，用 []，同类字符之间加一个 - 即可
    组合类
        [] 匹配不同类型的单个字符
    预定义类
        预定义的一些常用字符类，本质上是 [] 的马甲：
            . ：匹配除了换行和回车之外的任意字符，相当于 [^\n\r]
            \d：匹配数字字符，相当于 [0-9]
            \D：匹配非数字字符，相当于 [^0-9]
            \s：匹配空白字符，相当于 [ \t\n\x0B\f\r]
            \S：匹配非空白字符，相当于 [^ \t\n\x0B\f\r]
            \w：匹配单词字符 (所有的字母)，相当于 [a-zA-Z_0-9]
            \W：匹配非单词字符，相当于 [^a-zA-Z_0-9]

###### 量词

    简单量词：
        ?：软性量词 出现零次或一次
        *：软性量词 出现零次或多次 (任意次)
        +：软性量词 出现一次或多次 (至少一次)
        {n}：硬性量词 对应固定 n 次
        {n,m}：软性量词 至少出现 n 次但不超过 m 次
        {n,}：软性量词 至少出现 n 次 (+ 的升级版)
    
    贪婪量词、非贪婪量词、支配性量词：
        在合法的情况下，正则会尽量地多去匹配字符，这就叫做贪心模式。
        如果我们希望正则尽量少地匹配字符，只要在表示数字的符号后面加上一个?
        (即：问号加在量词的后边，则表示非贪婪模式)。
        组成如下的形式：{n,}?, *?, +?, ??, {m,n}?。
        上面两种模式都有个不断尝试的过程，而支配性量词却只尝试一次，如果不成功就算了
        (javascript 不支持该模式！)

###### 分组

    [] 方括号：表示范围内选择，
    {} 花括号：表示重复次数，
    () 圆括号：允许重复多个字符。

###### 反向引用

    反向引用标识正则表达式中的匹配组捕获的子字符串。
    每个反向引用都由一个编号或名称来标识，并通过“\编号“表示法在正则规则中进行引用。

###### 候选

    元字符 | 相当于正则表达式中的或，有一个候选项满足，就停止其它候选项匹配

###### 非捕获性分组

    不是所有分组都能创建反向引用，有一种特别的分组称之为非捕获性分组，它不会创建反向引用，即可以避免保存括号内的匹配结果。
    反之，就是捕获性分组。
    要创建一个非捕获性分组，只要在分组的左括号的后面紧跟一个问号与冒号就行了 ((?:pattern))

    注意：javascript 不存在命名分组

###### 前瞻

    正向前瞻
        形式：(?=pattern) 所谓正向前瞻，意思就是：要匹配的字符串，后面必须紧跟着 pattern
    负向前瞻
        形式 (?!pattern) 和?=恰好相反，要求字符串的后面不能紧跟着某个 pattern

###### 边界

    要与字符串合用的特殊字符，前面基本都用到了
        ^：开头
        $：结尾
        \b：单词边界 ([a-zA-Z_0-9] 之外的字符)
        \B：非单词边界

###### 什么是正则表达式的贪婪与非贪婪匹配

	前面的.*? 是非贪婪匹配的意思，表示找到最小的就可以了

	(?=Expression) 顺序环视，
	(?=\\() 匹配正括号

    如：String str="abcaxc";
    Patter p="ab*c";
    贪婪匹配:正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。
    如上面使用模式 p 匹配字符串 str，结果就是匹配到：abcaxc(ab*c)。
    非贪婪匹配：就是匹配到结果就好，就少的匹配字符。
    如上面使用模式 p 匹配字符串 str，结果就是匹配到：abc(ab*c)。

###### 编程中如何区分两种模式

    默认是贪婪模式；在量词后面直接加上一个问号？就是非贪婪模式。
    量词：{m,n}：m 到 n 个
    *：任意多个
    +：一个到多个
    ？：0 或一个
    
    . 表示除\n 之外的任意字符
    *表示匹配 0-无穷 
    + 表示匹配 1-无穷
    (?=Expression) 顺序环视，
    (?=\\() 就是匹配正括号
    懒惰模式正则： 
    src=".*? (?=\\()) "

#### 正则表达式使用实例

###### 匹配单行注释

```
//{1,2}[\s\S]*?\n
```

###### 匹配文档注释

```
/\*{1,2}[\s\S]*?\*/
```

###### 匹配不带 * 和数字的字符

```
^((?!\d|\*).)*$
```

###### 匹配不包含特定字符的行

```
^((?!\d).)*$
```

###### 匹配不带 * 和数字的非单空行

```
^[\s\S]{1}((?!\d|\*).)*\n
^[\s\S]?+((?!\d|\*).)*\n
```

###### 匹配不带 * 的行和空白行

```
^((?!\d|\*).)*\n$
```

###### 匹配 * 连着若干个空格

```
\*\s*
```

###### 匹配中英文排版加空格

```
([A-Za-z\+,!?])([\x{4e00}-\x{9fa5}])        $1 $2
([\x{4e00}-\x{9fa5}])([A-Za-z\+@])          $1 $2
```

---



